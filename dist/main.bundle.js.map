{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgl2-vs-webgpu/./src/triangle/webgl2/shader.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgl2/triangle.webgl2.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgpu/shader.wgsl","webpack://webgl2-vs-webgpu/./src/helpers/webgl2/createShader.ts","webpack://webgl2-vs-webgpu/./src/square/webgl2/square.webgl2.ts","webpack://webgl2-vs-webgpu/./src/helpers/webgl2/initialiseGL.ts","webpack://webgl2-vs-webgpu/./src/square/webgl2/shader.square.webgl.ts","webpack://webgl2-vs-webgpu/./src/helpers/webgl2/createProgram.ts","webpack://webgl2-vs-webgpu/./src/helpers/common/resizeCanvasToDisplaySize.ts","webpack://webgl2-vs-webgpu/./src/square/webgpu/shader.square.webgpu.wgsl","webpack://webgl2-vs-webgpu/./src/square/webgpu/square.webgpu.ts","webpack://webgl2-vs-webgpu/./src/helpers/webgpu/initialiseGPU.ts","webpack://webgl2-vs-webgpu/./src/helpers/webgpu/createGPUBuffer.ts","webpack://webgl2-vs-webgpu/./src/main.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgpu/triangle.webgpu.ts"],"sourcesContent":["export const vertexShaderSource:string = `#version 300 es\r\nin vec4 a_position; //data recieved from buffer\r\n\r\nvoid main(){\r\n    gl_Position = a_position; //assign data from buffer to special vertex shader variable for setting the positon of a vertex\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource:string = `#version 300 es\r\nprecision highp float;\r\n\r\nout vec4 outColor; //the output for the fragment shader\r\n\r\nvoid main(){\r\n    outColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}\r\n`","import { vertexShaderSource, fragmentShaderSource } from \"./shader\";\r\n\r\nconst createShader = (gl:WebGL2RenderingContext, type:number, source:string) => {\r\n    const shader:WebGLShader = gl.createShader(type) as WebGLShader;\r\n    gl.shaderSource(shader,source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if(success){\r\n        return shader;\r\n    }\r\n\r\n    gl.deleteShader(shader);\r\n}\r\nconst createProgram = (gl:WebGLRenderingContext, vertexShader:WebGLShader, fragmentShader:WebGLShader) => {\r\n    const program:WebGLProgram = gl.createProgram() as WebGLProgram;\r\n    gl.attachShader(program,vertexShader);\r\n    gl.attachShader(program,fragmentShader);\r\n    gl.linkProgram(program);\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if(success){\r\n        return program;\r\n    }\r\n    gl.deleteProgram(program);\r\n}\r\n\r\nexport const webgl2DrawTriangle = () => {\r\n    //get webgl rendering context\r\n    const canvas:HTMLCanvasElement = document.getElementById(\"canvas-webGL2\") as HTMLCanvasElement;\r\n    const gl:WebGL2RenderingContext = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\r\n\r\n    //create vertex and fragment shaders, and link them into a shader program\r\n    //the vertex shader used takes in vertex positions for drawing the triangle\r\n    //the fragment shader used has a predefined color for coloring the triangle\r\n    const vertexShader:WebGLShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource) as WebGLShader;\r\n    const fragmentShader:WebGLShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource) as WebGLShader;\r\n    const program:WebGLProgram = createProgram(gl,fragmentShader,vertexShader) as WebGLProgram;\r\n\r\n    //look up the position attribute location, create a position buffer(a buffer stores data) and bind the buffer\r\n    //binding the position buffer means its can be referenced through th ebind point moving forward\r\n    const positionAttributeLocation:number = gl.getAttribLocation(program, \"a_position\");\r\n    const positionBuffer:WebGLBuffer = gl.createBuffer() as WebGLBuffer;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n    //create an array to store the triangle vertices\r\n    //since we are dealing with 2d, we need just x and y coordinates\r\n    //the array should have 6 elements i.e. 3 points each with x and y coordinates\r\n    //we are dealing with clip space at this point, so coordinates should be from -1 to 1\r\n    const positions:number[] = [\r\n        -0.5,-0.5,\r\n        0.0, 0.5,\r\n        0.5, -0.5\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    //create a VAO to specify how the position attribute gets data from the buffer\r\n    //bind the created VAO so that all settings applied moving forward apply to it\r\n    //we use make sure we enable the attribute, using the attribute's loctaion\r\n    const vao:WebGLVertexArrayObject = gl.createVertexArray() as WebGLVertexArrayObject;\r\n    gl.bindVertexArray(vao);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    const size = 2;\r\n    const type = gl.FLOAT;\r\n    const normalize = false;\r\n    const stride = 0;\r\n    const offset = 0;\r\n\r\n    //note that the position buffer will be automatically binded to the attribute \r\n    //and the settings specifed will be used to get data from the buffer to the attribute\r\n    gl.vertexAttribPointer(positionAttributeLocation,size, type, normalize, stride, offset);\r\n\r\n    //adjust size of canvas\r\n    const displayWidth  = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    const needResize = canvas.width  !== displayWidth ||\r\n                       canvas.height !== displayHeight;\r\n    if (needResize) {\r\n      canvas.width  = displayWidth;\r\n      canvas.height = displayHeight;\r\n    }\r\n\r\n\r\n    gl.viewport(0,0,gl.canvas.width, gl.canvas.height); //convert clip space to pixels\r\n    gl.clearColor(1.0,1.0,1.0,1.0); //background color\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program); //use shader program with shaders linked\r\n\r\n    const primitiveType = gl.TRIANGLES; //draw triangles with the 3 vertices passed to the vertex shader\r\n    const drawOffset = 0;\r\n    const count = 3;\r\n    gl.drawArrays(primitiveType, drawOffset, count);\r\n}\r\n","export default \"//vertex shader\\r\\nstruct Ouput{\\r\\n    @builtin(position) Position: vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@vertex\\r\\nfn vs_main(@location(0) pos: vec4<f32>) -> Ouput{\\r\\n    var position = pos;\\r\\n\\r\\n    var color = vec4<f32>(0.0,0.0,1.0,1.0);\\r\\n\\r\\n    var output: Ouput;\\r\\n    output.Position = position;\\r\\n    output.vColor = color;\\r\\n    return output;\\r\\n}\\r\\n\\r\\n//fragment shader\\r\\n@fragment\\r\\nfn fs_main(@location(0) vColor:vec4<f32>) -> @location(0) vec4<f32>{\\r\\n    return vColor;\\r\\n}\"","const createShader = (gl:WebGL2RenderingContext, type:number, source:string) => {\r\n    const shader:WebGLShader = gl.createShader(type) as WebGLShader;\r\n    gl.shaderSource(shader,source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if(success){\r\n        return shader;\r\n    }\r\n    else console.log(gl.getShaderInfoLog(shader))\r\n\r\n    gl.deleteShader(shader);\r\n}\r\n\r\nexport default createShader;","import { vertexShaderSource, fragmentShaderSource } from \"./shader.square.webgl\"\r\nimport { createShader, createProgram, initialiseGL } from \"../../helpers/webgl2\"\r\nimport {resizeCanvasToDisplaySize} from \"../../helpers/common\"\r\nconst webGL2DrawSquare = () => {\r\n\r\n     //get webgl rendering context\r\n    const obj = initialiseGL();\r\n    const gl = obj[0] as WebGL2RenderingContext;\r\n    const canvas = obj[1] as HTMLCanvasElement;\r\n\r\n    //create vertex and fragment shaders, and link them into a shader program\r\n    //the vertex shader used takes in position and color for each vertex of the triangle\r\n    //the fragment shader used recieves a color from the vertex shader for each vertex of the triangle\r\n    const vertexShader:WebGLShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource) as WebGLShader;\r\n    const fragmentShader:WebGLShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource) as WebGLShader;\r\n    const program:WebGLProgram = createProgram(gl,fragmentShader,vertexShader) as WebGLProgram;\r\n\r\n    const data:number[] = [\r\n        -0.5,-0.5, 1.0,0.0,0.0,\r\n        -0.5, 0.5, 0.0,1.0,0.0,\r\n        0.5, -0.5, 0.0,1.0,0.0,\r\n        -0.5, 0.5, 0.0,1.0,0.0,\r\n        0.5, -0.5, 0.0,1.0,0.0,\r\n        0.5,0.5, 1.0,0.0,0.0,\r\n    ];\r\n\r\n    const dataBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, dataBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\r\n\r\n    const positionAttributeLocation = gl.getAttribLocation(program,\"a_position\");\r\n    const colorAttributeLocation = gl.getAttribLocation(program,\"a_color\");\r\n    \r\n    const vao = gl.createVertexArray();\r\n    gl.bindVertexArray(vao);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    let size = 2;\r\n    let type = gl.FLOAT;\r\n    let normalize = false;\r\n    let stride = 20;\r\n    let offset = 0;\r\n\r\n    gl.vertexAttribPointer(positionAttributeLocation,size, type, normalize, stride, offset);\r\n\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    size = 3;\r\n    type = gl.FLOAT;\r\n    normalize = false;\r\n    stride = 20;\r\n    offset = 8;\r\n    \r\n    gl.vertexAttribPointer(colorAttributeLocation,size, type, normalize, stride, offset);\r\n    gl.enableVertexAttribArray(colorAttributeLocation);\r\n    resizeCanvasToDisplaySize(canvas);\r\n\r\n    gl.viewport(0,0,gl.canvas.width, gl.canvas.height); //convert clip space to pixels\r\n    gl.clearColor(1.0,1.0,1.0,1.0); //background color\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program); //use shader program with shaders linked\r\n\r\n    const primitiveType = gl.TRIANGLES; //draw triangles with the 3 vertices passed to the vertex shader\r\n    const drawOffset = 0;\r\n    const count = 6;\r\n    gl.drawArrays(primitiveType, drawOffset, count);\r\n}\r\n\r\nexport default webGL2DrawSquare;","const initialiseGL = (id=\"canvas-webGL2\") => {\r\n        //get webgl rendering context\r\n        const canvas:HTMLCanvasElement = document.getElementById(id) as HTMLCanvasElement;\r\n        const gl:WebGL2RenderingContext = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\r\n        return [gl,canvas];\r\n}\r\n\r\nexport default initialiseGL;","export const vertexShaderSource:string = `#version 300 es\r\nin vec4 a_position; //position data recieved from buffer\r\nin vec4 a_color;  //also recieve color from buffer\r\nout vec4 out_color; //pass color to fragment shader\r\nvoid main(){\r\n    gl_Position = a_position; //assign data from buffer to special vertex shader variable for setting the positon of a vertex\r\n    out_color = a_color;\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource:string = `#version 300 es\r\nprecision highp float;\r\n\r\nin vec4 out_color; //the output for the fragment shader\r\nout vec4 outColor; //the output for the fragment shader\r\nvoid main(){\r\n    outColor = out_color;\r\n}\r\n`","const createProgram = (gl:WebGLRenderingContext, vertexShader:WebGLShader, fragmentShader:WebGLShader) => {\r\n    const program:WebGLProgram = gl.createProgram() as WebGLProgram;\r\n    gl.attachShader(program,vertexShader);\r\n    gl.attachShader(program,fragmentShader);\r\n    gl.linkProgram(program);\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if(success){\r\n        return program;\r\n    }\r\n    gl.deleteProgram(program);\r\n}\r\n\r\nexport default createProgram;","const resizeCanvasToDisplaySize = (canvas:HTMLCanvasElement) => {\r\n    const displayWidth  = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    const needResize = canvas.width  !== displayWidth ||\r\n                       canvas.height !== displayHeight;\r\n    if (needResize) {\r\n      canvas.width  = displayWidth;\r\n      canvas.height = displayHeight;\r\n    }\r\n    return needResize;\r\n}\r\n\r\nexport default resizeCanvasToDisplaySize;","export default \"//vertex shader\\r\\nstruct Ouput{\\r\\n    @builtin(position) Position: vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@vertex\\r\\nfn vs_main(@location(1) pos: vec4<f32>, @location(2) col: vec4<f32>) -> Ouput{\\r\\n    var position = pos;\\r\\n    var color = col;\\r\\n\\r\\n    var output: Ouput;\\r\\n    output.Position = position;\\r\\n    output.vColor = color;\\r\\n    return output;\\r\\n}\\r\\n\\r\\n//fragment shader\\r\\n@fragment\\r\\nfn fs_main(@location(0) vColor:vec4<f32>) -> @location(0) vec4<f32>{\\r\\n    return vColor;\\r\\n}\"","import shader from './shader.square.webgpu.wgsl'\r\nimport { initialiseGPU, createGPUBuffer } from '../../helpers/webgpu';\r\nconst webGPUDrawSquare = async () => {\r\n    const gpu = await initialiseGPU();\r\n    const format = 'bgra8unorm';\r\n    const device = gpu.device;\r\n    const context = gpu.context;\r\n\r\n    const data:Float32Array = new Float32Array([\r\n        -0.5,-0.5, 0.0,0.0,1.0,\r\n        -0.5, 0.5, 0.0,1.0,0.0,\r\n        0.5, -0.5, 0.0,1.0,0.0,\r\n        -0.5, 0.5, 0.0,1.0,0.0,\r\n        0.5, -0.5, 0.0,1.0,0.0,\r\n        0.5,0.5, 0.0,0.0,1.0,\r\n    ]);\r\n\r\n    const dataBuffer = createGPUBuffer(device, data, GPUBufferUsage.VERTEX);\r\n\r\n    let pipeline = device.createRenderPipeline({\r\n        vertex:{\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint: \"vs_main\",\r\n            buffers:[\r\n                {\r\n                    arrayStride:20,\r\n                    attributes:[\r\n                        {\r\n                            shaderLocation:1,\r\n                            format:\"float32x2\",\r\n                            offset:0\r\n                        },\r\n                        {\r\n                            shaderLocation:2,\r\n                            format:\"float32x3\",\r\n                            offset:8\r\n                        }\r\n                ]\r\n                }\r\n            ]\r\n        },\r\n        fragment:{\r\n            module:device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint:\"fs_main\",\r\n            targets:[{format}]\r\n        },\r\n        primitive:{\r\n            topology:\"triangle-list\"\r\n        },\r\n        layout: device.createPipelineLayout({\r\n            bindGroupLayouts:[]\r\n        })\r\n    })\r\n\r\n    \r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = context.getCurrentTexture().createView();\r\n    const renderPass = commandEncoder.beginRenderPass({ \r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:1.0, g:1.0, b:1.0, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    })\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, dataBuffer);\r\n    renderPass.draw(6,1,0,0);\r\n    \r\n    renderPass.end(); //no more instructions \r\n    device.queue.submit([commandEncoder.finish()]) //submit to the gpu's queue to execute\r\n}\r\n\r\nexport default webGPUDrawSquare;","const checkGPU = () => {\r\n    let result = '';\r\n    if(!navigator.gpu){\r\n        result = \"Your current browser does not support WebGPU\";\r\n    }\r\n    return result;\r\n}\r\n\r\nconst initialiseGPU = async (id=\"canvas-webGPU\") => {\r\n    const status = checkGPU();\r\n    if(status!==''){\r\n        window.alert('No WebGPU Support');\r\n    }\r\n\r\n    const canvas = document.getElementById(id) as HTMLCanvasElement;\r\n    const adapter = await navigator.gpu?.requestAdapter(); //the gpu\r\n    const device = await adapter?.requestDevice() as GPUDevice; //provides a connection to the adapter(the gpu)\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n    \r\n    //adjust size of canvas\r\n    const displayWidth  = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    const needResize = canvas.width  !== displayWidth ||\r\n                       canvas.height !== displayHeight;\r\n    if (needResize) {\r\n      canvas.width  = displayWidth;\r\n      canvas.height = displayHeight;\r\n    }\r\n\r\n    const format = await navigator.gpu.getPreferredCanvasFormat();\r\n\r\n    context.configure({\r\n        alphaMode:\"premultiplied\", device, format\r\n    })\r\n\r\n    return {device, canvas, format, context}\r\n}\r\n\r\nexport default initialiseGPU;","const createGPUBuffer = (device:GPUDevice, data: Float32Array, usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage:usageFlag,\r\n        mappedAtCreation: true\r\n    });\r\n\r\n    new Float32Array(buffer.getMappedRange()).set(data);\r\n    buffer.unmap();\r\n    return buffer;\r\n}\r\n\r\nexport default createGPUBuffer;","import { webgl2DrawTriangle } from \"./triangle/webgl2\";\r\nimport { webgpuDrawTriangle } from \"./triangle/webgpu\"\r\nimport { webGL2DrawSquare } from \"./square/webgl2\";\r\nimport { webGPUDrawSquare } from \"./square/webgpu\";\r\n\r\nconst removeOtherScene = (sceneType:string) => {\r\n    const sceneParent = document.getElementById(sceneType) as HTMLElement;\r\n    sceneParent?.childNodes.forEach((node)=>{\r\n        if(node.nodeName===\"CANVAS\"){\r\n            node.remove()\r\n        }\r\n    })\r\n}\r\nconst setThisScene = (sceneType:string) => {\r\n    let needsSetup = true;\r\n    const sceneParent = document.getElementById(sceneType) as HTMLElement;\r\n    sceneParent?.childNodes.forEach((node)=>{\r\n        if(node.nodeName===\"CANVAS\"){\r\n            needsSetup = false;\r\n        }\r\n    })\r\n\r\n    if(needsSetup){\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.id=\"canvas-\"+sceneType;\r\n        sceneParent.appendChild(canvas);\r\n    }\r\n}\r\n\r\nconst triangleButtoWebGPU:HTMLElement|null = document.getElementById(\"webGPUTab-triangle\");\r\ntriangleButtoWebGPU?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGL2\");\r\n    setThisScene(\"webGPU\");\r\n    await webgpuDrawTriangle();\r\n})\r\nconst triangleButtoWebGL2:HTMLElement|null = document.getElementById(\"webGL2Tab-triangle\");\r\ntriangleButtoWebGL2?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGPU\");\r\n    setThisScene(\"webGL2\");\r\n    webgl2DrawTriangle();\r\n})\r\nif(triangleButtoWebGL2!==null)webgl2DrawTriangle();\r\n\r\nconst squareButtoWebGPU:HTMLElement|null = document.getElementById(\"webGPUTab-square\");\r\nsquareButtoWebGPU?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGL2\");\r\n    setThisScene(\"webGPU\");\r\n    await webGPUDrawSquare();\r\n})\r\nconst squareButtoWebGL2:HTMLElement|null = document.getElementById(\"webGL2Tab-square\");\r\nsquareButtoWebGL2?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGPU\");\r\n    setThisScene(\"webGL2\");\r\n    webGL2DrawSquare();\r\n})\r\nif(squareButtoWebGL2!==null)webGL2DrawSquare();","import shader from './shader.wgsl';\r\nconst checkGPU = () => {\r\n    let result = '';\r\n    if(!navigator.gpu){\r\n        result = \"Your current browser does not support WebGPU\";\r\n    }\r\n    return result;\r\n}\r\n\r\nconst initGPU = async (id=\"canvas-webGPU\") => {\r\n    const status = checkGPU();\r\n    if(status!==''){\r\n        window.alert('No WebGPU Support');\r\n    }\r\n\r\n    const canvas = document.getElementById(id) as HTMLCanvasElement;\r\n    const adapter = await navigator.gpu?.requestAdapter(); //the gpu\r\n    const device = await adapter?.requestDevice() as GPUDevice; //provides a connection to the adapter(the gpu)\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n    \r\n    //adjust size of canvas\r\n    const displayWidth  = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    const needResize = canvas.width  !== displayWidth ||\r\n                       canvas.height !== displayHeight;\r\n    if (needResize) {\r\n      canvas.width  = displayWidth;\r\n      canvas.height = displayHeight;\r\n    }\r\n\r\n    const format = await navigator.gpu.getPreferredCanvasFormat();\r\n\r\n    context.configure({\r\n        alphaMode:\"premultiplied\", device, format\r\n    })\r\n\r\n    return {device, canvas, format, context}\r\n}\r\n\r\nexport const webgpuDrawTriangle = async () => {\r\n    //check WebGPU support, configure context, a gpu object\r\n    const gpu = await initGPU();\r\n    const format = 'bgra8unorm';\r\n    const device = gpu.device;\r\n    const context = gpu.context;\r\n\r\n    //create an array to store the triangle vertices\r\n    //since we are dealing with 2d, we need just x and y coordinates\r\n    //we are dealing with clip space at this point, so coordinates should be from -1 to 1\r\n    const positions:Float32Array = new Float32Array([\r\n        -0.5,-0.5,\r\n        0.0, 0.5,\r\n        0.5, -0.5\r\n    ]);\r\n\r\n    //create a position buffer(a buffer stores data) for use in the vertex shader\r\n    //store the array of vertices into the buufer\r\n    const positionBuffer = device.createBuffer({\r\n        size: positions.byteLength,\r\n        usage:GPUBufferUsage.VERTEX,\r\n        mappedAtCreation: true\r\n    });\r\n\r\n    new Float32Array(positionBuffer.getMappedRange()).set(positions);\r\n    positionBuffer.unmap();\r\n\r\n\r\n    //create and setup a render pipeline which controls the vertex and fragment shader stages\r\n    //specify vertex and fragment shaders, specify primitive topology to draw, specify no bindGrouplayouts\r\n    //spefiy the position buufer in the buffers property of th evertex shader\r\n    let pipeline:GPURenderPipeline;\r\n    pipeline = device.createRenderPipeline({\r\n        vertex:{\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint: \"vs_main\",\r\n            buffers:[\r\n                {\r\n                    arrayStride:8,\r\n                    attributes:[{\r\n                        shaderLocation:0,\r\n                        format:\"float32x2\",\r\n                        offset:0\r\n                    }\r\n                    ]\r\n                }\r\n            ]\r\n        },\r\n        fragment:{\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint:\"fs_main\",\r\n            targets: [{format}]\r\n        },\r\n        primitive: {\r\n            topology: \"triangle-list\"\r\n        },\r\n        layout: device.createPipelineLayout({\r\n            bindGroupLayouts:[]\r\n        })\r\n    })\r\n\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = context.getCurrentTexture().createView();\r\n    const renderPass = commandEncoder.beginRenderPass({ \r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:1.0, g:1.0, b:1.0, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    })\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, positionBuffer);\r\n    renderPass.draw(3,1,0,0);\r\n    \r\n    renderPass.end(); //no more instructions \r\n    device.queue.submit([commandEncoder.finish()]) //submit to the gpu's queue to execute\r\n}"],"names":["createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","webgl2DrawTriangle","canvas","document","getElementById","getContext","vertexShader","VERTEX_SHADER","program","fragmentShader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","deleteProgram","FRAGMENT_SHADER","positionAttributeLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vao","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","vertexAttribPointer","displayWidth","clientWidth","displayHeight","clientHeight","width","height","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","primitiveType","TRIANGLES","drawArrays","console","log","getShaderInfoLog","obj","id","dataBuffer","colorAttributeLocation","size","normalize","stride","offset","needResize","async","gpu","result","navigator","window","alert","adapter","requestAdapter","device","requestDevice","context","format","getPreferredCanvasFormat","configure","alphaMode","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","fragment","targets","primitive","topology","layout","createPipelineLayout","bindGroupLayouts","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","draw","end","queue","submit","finish","removeOtherScene","sceneType","sceneParent","childNodes","forEach","node","nodeName","remove","setThisScene","needsSetup","createElement","appendChild","triangleButtoWebGPU","addEventListener","checkGPU","initGPU","positions","webgpuDrawTriangle","triangleButtoWebGL2","squareButtoWebGPU","squareButtoWebGL2"],"sourceRoot":""}