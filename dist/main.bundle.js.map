{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgl2-vs-webgpu/./src/triangle/webgl2/shader.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgl2/index.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgpu/shader.wgsl","webpack://webgl2-vs-webgpu/./src/main.ts","webpack://webgl2-vs-webgpu/./src/triangle/webgpu/index.ts"],"sourcesContent":["export const vertexShaderSource:string = `#version 300 es\r\nin vec4 a_position; //data recieved from buffer\r\n\r\nvoid main(){\r\n    gl_Position = a_position; //assign data from buffer to special vertex shader variable for setting the positon of a vertex\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource:string = `#version 300 es\r\nprecision highp float;\r\n\r\nout vec4 outColor; //the output for the fragment shader\r\n\r\nvoid main(){\r\n    outColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}\r\n`","import { vertexShaderSource, fragmentShaderSource } from \"./shader\";\r\nexport const resizeCanvasToDisplaySize = (canvas:HTMLCanvasElement) => {\r\n    const displayWidth  = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    const needResize = canvas.width  !== displayWidth ||\r\n                       canvas.height !== displayHeight;\r\n    if (needResize) {\r\n      canvas.width  = displayWidth;\r\n      canvas.height = displayHeight;\r\n    }\r\n    return needResize;\r\n}\r\nconst createShader = (gl:WebGL2RenderingContext, type:number, source:string) => {\r\n    const shader:WebGLShader = gl.createShader(type) as WebGLShader;\r\n    gl.shaderSource(shader,source);\r\n    gl.compileShader(shader);\r\n    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if(success){\r\n        return shader;\r\n    }\r\n\r\n    gl.deleteShader(shader);\r\n}\r\nconst createProgram = (gl:WebGLRenderingContext, vertexShader:WebGLShader, fragmentShader:WebGLShader) => {\r\n    const program:WebGLProgram = gl.createProgram() as WebGLProgram;\r\n    gl.attachShader(program,vertexShader);\r\n    gl.attachShader(program,fragmentShader);\r\n    gl.linkProgram(program);\r\n    const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if(success){\r\n        return program;\r\n    }\r\n    gl.deleteProgram(program);\r\n}\r\n\r\nexport const webgl2DrawTriangle = () => {\r\n    //get webgl rendering context\r\n    const canvas:HTMLCanvasElement = document.getElementById(\"canvas-webGL2\") as HTMLCanvasElement;\r\n    const gl:WebGL2RenderingContext = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\r\n\r\n    //create vertex and fragment shaders, and link them into a shader program\r\n    //the vertex shader used takes in vertex positions for drawing the triangle\r\n    //the fragment shader used has a predefined color for coloring the triangle\r\n    const vertexShader:WebGLShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource) as WebGLShader;\r\n    const fragmentShader:WebGLShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource) as WebGLShader;\r\n    const program:WebGLProgram = createProgram(gl,fragmentShader,vertexShader) as WebGLProgram;\r\n\r\n    //look up the position attribute location, create a position buffer(a buffer stores data) and bind the buffer\r\n    //binding the position buffer means its can be referenced through th ebind point moving forward\r\n    const positionAttributeLocation:number = gl.getAttribLocation(program, \"a_position\");\r\n    const positionBuffer:WebGLBuffer = gl.createBuffer() as WebGLBuffer;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n    //create an array to store the triangle vertices\r\n    //since we are dealing with 2d, we need just x and y coordinates\r\n    //the array should have 6 elements i.e. 3 points each with x and y coordinates\r\n    //we are dealing with clip space at this point, so coordinates should be from -1 to 1\r\n    const positions:number[] = [\r\n        -0.5,-0.5,\r\n        0.0, 0.5,\r\n        0.5, -0.5\r\n    ];\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\r\n\r\n    //create a VAO to specify how the position attribute gets data from the buffer\r\n    //bind the created VAO so that all settings applied moving forward apply to it\r\n    //we use make sure we enable the attribute, using the attribute's loctaion\r\n    const vao:WebGLVertexArrayObject = gl.createVertexArray() as WebGLVertexArrayObject;\r\n    gl.bindVertexArray(vao);\r\n    gl.enableVertexAttribArray(positionAttributeLocation);\r\n    const size = 2;\r\n    const type = gl.FLOAT;\r\n    const normalize = false;\r\n    const stride = 0;\r\n    const offset = 0;\r\n\r\n    //note that the position buffer will be automatically binded to the attribute \r\n    //and the settings specifed will be used to get data from the buffer to the attribute\r\n    gl.vertexAttribPointer(positionAttributeLocation,size, type, normalize, stride, offset);\r\n\r\n    resizeCanvasToDisplaySize(canvas); //adjust size of canvas\r\n    gl.viewport(0,0,gl.canvas.width, gl.canvas.height); //convert clip space to pixels\r\n    gl.clearColor(1.0,1.0,1.0,1.0); //background color\r\n    gl.clear(gl.COLOR_BUFFER_BIT);\r\n    gl.useProgram(program); //use shader program with shaders linked\r\n\r\n    const primitiveType = gl.TRIANGLES; //draw triangles with the 3 vertices passed to the vertex shader\r\n    const drawOffset = 0;\r\n    const count = 3;\r\n    gl.drawArrays(primitiveType, drawOffset, count);\r\n}\r\n","export default \"//vertex shader\\r\\nstruct Ouput{\\r\\n    @builtin(position) Position: vec4<f32>,\\r\\n    @location(0) vColor : vec4<f32>\\r\\n};\\r\\n\\r\\n@vertex\\r\\nfn vs_main(@location(0) pos: vec4<f32>) -> Ouput{\\r\\n    var position = pos;\\r\\n\\r\\n    var color = vec4<f32>(0.0,0.0,1.0,1.0);\\r\\n\\r\\n    var output: Ouput;\\r\\n    output.Position = position;\\r\\n    output.vColor = color;\\r\\n    return output;\\r\\n}\\r\\n\\r\\n//fragment shader\\r\\n@fragment\\r\\nfn fs_main(@location(0) vColor:vec4<f32>) -> @location(0) vec4<f32>{\\r\\n    return vColor;\\r\\n}\"","import { webgl2DrawTriangle } from \"./triangle/webgl2\";\r\nimport { webgpuDrawTriangle } from \"./triangle/webgpu\"\r\n\r\nconst removeOtherScene = (sceneType:string) => {\r\n    const sceneParent = document.getElementById(sceneType) as HTMLElement;\r\n    sceneParent?.childNodes.forEach((node)=>{\r\n        if(node.nodeName===\"CANVAS\"){\r\n            node.remove()\r\n        }\r\n    })\r\n}\r\nconst setThisScene = (sceneType:string) => {\r\n    let needsSetup = true;\r\n    const sceneParent = document.getElementById(sceneType) as HTMLElement;\r\n    sceneParent?.childNodes.forEach((node)=>{\r\n        if(node.nodeName===\"CANVAS\"){\r\n            needsSetup = false;\r\n        }\r\n    })\r\n\r\n    if(needsSetup){\r\n        const canvas = document.createElement(\"canvas\");\r\n        canvas.id=\"canvas-\"+sceneType;\r\n        sceneParent.appendChild(canvas);\r\n    }\r\n}\r\n\r\nconst triangleButtoWebGPU:HTMLElement|null = document.getElementById(\"webGPUTab-triangle\");\r\ntriangleButtoWebGPU?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGL2\");\r\n    setThisScene(\"webGPU\");\r\n    await webgpuDrawTriangle();\r\n})\r\nconst triangleButtoWebGL2:HTMLElement|null = document.getElementById(\"webGL2Tab-triangle\");\r\ntriangleButtoWebGL2?.addEventListener(\"click\",async ()=>{\r\n    removeOtherScene(\"webGPU\");\r\n    setThisScene(\"webGL2\");\r\n    webgl2DrawTriangle();\r\n})\r\nif(triangleButtoWebGL2!==null)webgl2DrawTriangle();","import shader from './shader.wgsl';\r\nimport {resizeCanvasToDisplaySize} from \"../webgl2\"\r\nconst checkGPU = () => {\r\n    let result = '';\r\n    if(!navigator.gpu){\r\n        result = \"Your current browser does not support WebGPU\";\r\n    }\r\n    return result;\r\n}\r\n\r\nconst initGPU = async (id=\"canvas-webGPU\") => {\r\n    const status = checkGPU();\r\n    if(status!==''){\r\n        throw('No WebGPU Support');\r\n    }\r\n\r\n    const canvas = document.getElementById(id) as HTMLCanvasElement;\r\n    const adapter = await navigator.gpu?.requestAdapter(); //the gpu\r\n    const device = await adapter?.requestDevice() as GPUDevice; //provides a connection to the adapter(the gpu)\r\n    const context = canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n\r\n    resizeCanvasToDisplaySize(canvas)\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const size = [\r\n        canvas.clientWidth *devicePixelRatio,\r\n        canvas.clientHeight *devicePixelRatio\r\n    ];\r\n    canvas.width = size[0];\r\n    canvas.height = size[1];\r\n    const format = await navigator.gpu.getPreferredCanvasFormat();\r\n\r\n    context.configure({\r\n        alphaMode:\"premultiplied\", device, format\r\n    })\r\n\r\n    return {device, canvas, format, context}\r\n}\r\n\r\nexport const webgpuDrawTriangle = async () => {\r\n    //check WebGPU support, configure context, a gpu object\r\n    const gpu = await initGPU();\r\n    const format = 'bgra8unorm';\r\n    const device = gpu.device;\r\n    const context = gpu.context;\r\n\r\n    //create an array to store the triangle vertices\r\n    //since we are dealing with 2d, we need just x and y coordinates\r\n    //we are dealing with clip space at this point, so coordinates should be from -1 to 1\r\n    const positions:Float32Array = new Float32Array([\r\n        -0.5,-0.5,\r\n        0.0, 0.5,\r\n        0.5, -0.5\r\n    ]);\r\n\r\n    //create a position buffer(a buffer stores data) for use in the vertex shader\r\n    //store the array of vertices into the buufer\r\n    const positionBuffer = device.createBuffer({\r\n        size: positions.byteLength,\r\n        usage:GPUBufferUsage.VERTEX,\r\n        mappedAtCreation: true\r\n    });\r\n\r\n    new Float32Array(positionBuffer.getMappedRange()).set(positions);\r\n    positionBuffer.unmap();\r\n\r\n\r\n    //create and setup a render pipeline which controls the vertex and fragment shader stages\r\n    //specify vertex and fragment shaders, specify primitive topology to draw, specify no bindGrouplayouts\r\n    //spefiy the position buufer in the buffers property of th evertex shader\r\n    let pipeline:GPURenderPipeline;\r\n    pipeline = device.createRenderPipeline({\r\n        vertex:{\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint: \"vs_main\",\r\n            buffers:[\r\n                {\r\n                    arrayStride:8,\r\n                    attributes:[{\r\n                        shaderLocation:0,\r\n                        format:\"float32x2\",\r\n                        offset:0\r\n                    }\r\n                    ]\r\n                }\r\n            ]\r\n        },\r\n        fragment:{\r\n            module: device.createShaderModule({\r\n                code:shader\r\n            }),\r\n            entryPoint:\"fs_main\",\r\n            targets: [{format}]\r\n        },\r\n        primitive: {\r\n            topology: \"triangle-list\"\r\n        },\r\n        layout: device.createPipelineLayout({\r\n            bindGroupLayouts:[]\r\n        })\r\n    })\r\n\r\n\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const textureView = context.getCurrentTexture().createView();\r\n    const renderPass = commandEncoder.beginRenderPass({ \r\n        colorAttachments: [{\r\n            view:textureView,\r\n            clearValue:{r:1.0, g:1.0, b:1.0, a:1.0},\r\n            loadOp: 'clear',\r\n            storeOp:'store'\r\n        }]\r\n    })\r\n\r\n    renderPass.setPipeline(pipeline);\r\n    renderPass.setVertexBuffer(0, positionBuffer);\r\n    renderPass.draw(3,1,0,0);\r\n    \r\n    renderPass.end(); //no more instructions \r\n    device.queue.submit([commandEncoder.finish()]) //submit to the gpu's queue to execute\r\n}"],"names":["resizeCanvasToDisplaySize","canvas","displayWidth","clientWidth","displayHeight","clientHeight","needResize","width","height","createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","webgl2DrawTriangle","document","getElementById","getContext","vertexShader","VERTEX_SHADER","program","fragmentShader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","deleteProgram","FRAGMENT_SHADER","positionAttributeLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vao","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","vertexAttribPointer","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","primitiveType","TRIANGLES","drawArrays","removeOtherScene","sceneType","sceneParent","childNodes","forEach","node","nodeName","remove","setThisScene","needsSetup","createElement","id","appendChild","triangleButtoWebGPU","addEventListener","async","gpu","result","navigator","checkGPU","adapter","requestAdapter","device","requestDevice","context","devicePixelRatio","window","size","format","getPreferredCanvasFormat","configure","alphaMode","initGPU","positions","byteLength","usage","GPUBufferUsage","VERTEX","mappedAtCreation","pipeline","getMappedRange","set","unmap","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","layout","createPipelineLayout","bindGroupLayouts","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setPipeline","setVertexBuffer","draw","end","queue","submit","finish","webgpuDrawTriangle","triangleButtoWebGL2"],"sourceRoot":""}