(()=>{"use strict";const e=e=>{const t=e.clientWidth,r=e.clientHeight,n=e.width!==t||e.height!==r;return n&&(e.width=t,e.height=r),n},t=(e,t,r)=>{const n=e.createShader(t);if(e.shaderSource(n,r),e.compileShader(n),e.getShaderParameter(n,e.COMPILE_STATUS))return n;e.deleteShader(n)},r=()=>{const r=document.getElementById("canvas-webGL2"),n=r.getContext("webgl2"),a=t(n,n.VERTEX_SHADER,"#version 300 es\nin vec4 a_position; //data recieved from buffer\n\nvoid main(){\n    gl_Position = a_position; //assign data from buffer to special vertex shader variable for setting the positon of a vertex\n}\n"),o=((e,t,r)=>{const n=e.createProgram();if(e.attachShader(n,t),e.attachShader(n,r),e.linkProgram(n),e.getProgramParameter(n,e.LINK_STATUS))return n;e.deleteProgram(n)})(n,t(n,n.FRAGMENT_SHADER,"#version 300 es\nprecision highp float;\n\nout vec4 outColor; //the output for the fragment shader\n\nvoid main(){\n    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"),a),i=n.getAttribLocation(o,"a_position"),c=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,c),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-.5,-.5,0,.5,.5,-.5]),n.STATIC_DRAW);const s=n.createVertexArray();n.bindVertexArray(s),n.enableVertexAttribArray(i);const d=n.FLOAT;n.vertexAttribPointer(i,2,d,!1,0,0),e(r),n.viewport(0,0,n.canvas.width,n.canvas.height),n.clearColor(1,1,1,1),n.clear(n.COLOR_BUFFER_BIT),n.useProgram(o);const l=n.TRIANGLES;n.drawArrays(l,0,3)},n="//vertex shader\r\nstruct Ouput{\r\n    @builtin(position) Position: vec4<f32>,\r\n    @location(0) vColor : vec4<f32>\r\n};\r\n\r\n@vertex\r\nfn vs_main(@location(0) pos: vec4<f32>) -> Ouput{\r\n    var position = pos;\r\n\r\n    var color = vec4<f32>(0.0,0.0,1.0,1.0);\r\n\r\n    var output: Ouput;\r\n    output.Position = position;\r\n    output.vColor = color;\r\n    return output;\r\n}\r\n\r\n//fragment shader\r\n@fragment\r\nfn fs_main(@location(0) vColor:vec4<f32>) -> @location(0) vec4<f32>{\r\n    return vColor;\r\n}",a=e=>{const t=document.getElementById(e);null==t||t.childNodes.forEach((e=>{"CANVAS"===e.nodeName&&e.remove()}))},o=e=>{let t=!0;const r=document.getElementById(e);if(null==r||r.childNodes.forEach((e=>{"CANVAS"===e.nodeName&&(t=!1)})),t){const t=document.createElement("canvas");t.id="canvas-"+e,r.appendChild(t)}},i=document.getElementById("webGPUTab-triangle");null==i||i.addEventListener("click",(async()=>{a("webGL2"),o("webGPU"),await(async()=>{const t=await(async(t="canvas-webGPU")=>{var r;if(""!==(()=>{let e="";return navigator.gpu||(e="Your current browser does not support WebGPU"),e})())throw"No WebGPU Support";const n=document.getElementById(t),a=await(null===(r=navigator.gpu)||void 0===r?void 0:r.requestAdapter()),o=await(null==a?void 0:a.requestDevice()),i=n.getContext("webgpu");e(n);const c=window.devicePixelRatio||1,s=[n.clientWidth*c,n.clientHeight*c];n.width=s[0],n.height=s[1];const d=await navigator.gpu.getPreferredCanvasFormat();return i.configure({alphaMode:"premultiplied",device:o,format:d}),{device:o,canvas:n,format:d,context:i}})(),r=t.device,a=t.context,o=new Float32Array([-.5,-.5,0,.5,.5,-.5]),i=r.createBuffer({size:o.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});let c;new Float32Array(i.getMappedRange()).set(o),i.unmap(),c=r.createRenderPipeline({vertex:{module:r.createShaderModule({code:n}),entryPoint:"vs_main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,format:"float32x2",offset:0}]}]},fragment:{module:r.createShaderModule({code:n}),entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"},layout:r.createPipelineLayout({bindGroupLayouts:[]})});const s=r.createCommandEncoder(),d=a.getCurrentTexture().createView(),l=s.beginRenderPass({colorAttachments:[{view:d,clearValue:{r:1,g:1,b:1,a:1},loadOp:"clear",storeOp:"store"}]});l.setPipeline(c),l.setVertexBuffer(0,i),l.draw(3,1,0,0),l.end(),r.queue.submit([s.finish()])})()}));const c=document.getElementById("webGL2Tab-triangle");null==c||c.addEventListener("click",(async()=>{a("webGPU"),o("webGL2"),r()})),null!==c&&r()})();
//# sourceMappingURL=main.bundle.js.map